<!DOCTYPE html>
<html lang="en">
<title>City3D</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="index.css">
<body>
<div class="f4 f1-ns fw4 ma4 title">Intersection Test<sup class="h-25 fw1">3d</sup></div>

<div class="flex flex-column ma4 vh-50 vh-75-l overflow-hidden">
    <canvas class="h-inherit" tabindex='1' id="scene"></canvas>
</div>

<script id="vertexShader" type="x-shader/x-vertex">
    #version 300 es

    const int MAX_GRID_SIZE = 100;
    const int MAX_BUILDING_HEIGHT = 51;

    precision mediump float;
    precision mediump usampler2D;

    uniform mat4 mvp;
    uniform int gridSize;
    uniform int seed;

    uniform usampler2D globalBuffer;

    in vec4 position;
    flat out int buildingColor;

    float scale(float n, float inMin, float inMax, float outMin, float outMax) {
        return ((n - inMin) * (outMax - outMin)) / ((inMax - inMin) + outMin);
    }

    int getIntAtIndex(usampler2D oneDBuffer, int index) {
        return int(texelFetch(oneDBuffer, ivec2(index, 0), 0).r);
    }

    void main() {
        // We prevent moire patterns from forming in the output by using an array of 
        // prime numbers in our LCG instead of two single numbers for the entire grid.
        int gridSizeSquared = gridSize * gridSize;

        int metaIndex =
            (gl_InstanceID * getIntAtIndex(globalBuffer, int(gl_InstanceID % MAX_GRID_SIZE)))
            % gridSizeSquared;

        int buildingIndex = 
            (gl_InstanceID * getIntAtIndex(globalBuffer, int((metaIndex + seed) % MAX_GRID_SIZE))) 
            % gridSizeSquared;

        // 1D Index to 2D Index (top left origin, row major)
        float col = float(buildingIndex % gridSize);
        float row = float(buildingIndex / gridSize);

        // 2D index to World Coordinate System
        float halfOfGrid = float(gridSize) * 0.5f;
        col = scale(col, 0.0, float(gridSize), -halfOfGrid, halfOfGrid);
        row = scale(row, 0.0, float(gridSize), -halfOfGrid, halfOfGrid);

        // Vectors for positioning the xz location of each building and 
        // the group of buildings themselves
        vec4 buildingOffset = vec4(col, 0, row, 0);
        vec4 sceneOffset = vec4(-gridSize, 0, -gridSize, 0);

        // LCG for random heights / colors
        float randomHeight = float(
            (buildingIndex * getIntAtIndex(globalBuffer, buildingIndex % MAX_GRID_SIZE) 
            % MAX_BUILDING_HEIGHT)
        );

        buildingColor = int(
            float(buildingIndex) * 
            randomHeight * 
            float(metaIndex) +
            float(gl_InstanceID)
        );

        // Stretch the buildings conditionally: only positive y vertices (those closest to
        // the roof should scale), i.e like a building.
        vec4 pos = position;
        pos.y += (randomHeight / 2.0) * (pos.y < 0.0 ? 0.0 : 1.0);

        gl_Position = mvp * (sceneOffset + buildingOffset + pos);
    }
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
    #version 300 es
    precision mediump float;
    flat in int buildingColor;
    out vec4 outColor;

    vec3 unpackColor(int c) {
        vec3 color;
        color.r = float((c >> 16) & 255) / 255.0;
        color.g = float((c >> 8) & 255) / 255.0;
        color.b = float(c & 255) / 255.0;
        return color;
    }

    void main() {
        outColor = vec4(unpackColor(buildingColor), 1);
    }
</script>

</body>
</html>
